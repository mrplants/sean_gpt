""" This module contains the route for monitoring file processing status via websocket.
"""
import uuid

from fastapi import APIRouter, WebSocket, status, WebSocketException, WebSocketDisconnect, Query
from sqlmodel import select

from ...util.describe import describe
from ...config import settings
from ...util.database import RedisConnectionDep, SessionDep
from ...util.user import IsVerifiedUserDep
from ...model.file import File, ORDERED_FILE_STATUSES

router = APIRouter(prefix="/file/processing")

@describe(
""" Create a chat completion token.

Args:
    current_user (AuthenticatedUser):  The user making the request.

Returns:
    dict: A dictionary containing the token.
""")
@router.get("/token", dependencies=[IsVerifiedUserDep])
async def generate_chat_response( # pylint: disable=missing-function-docstring
    redis_conn: RedisConnectionDep):
    # Create the token using uuid4
    token = str(uuid.uuid4())
    # Save the token in redis with a timeout
    await redis_conn.set(token, 1, ex=settings.app_ws_token_timeout_seconds)
    # Return the token
    return {"token": token}

@describe(
""" Generates a chat completion stream via websocket.

The current file status is stored in the file record of the postgres database.  Redis is used for
inter-process communication, so there is a pubsub channel where file status notifications are
published.

Args:
    token (str):  The token generated by the /token endpoint.
    redis_conn (RedisConnectionDep):  The redis connection.
    session (SessionDep):  The database session.
    websocket (WebSocket):  The websocket connection.
""")
@router.websocket("/ws")
async def generate_chat_stream( # pylint: disable=missing-function-docstring
    *,
    token: str = Query(),
    redis_conn: RedisConnectionDep,
    session: SessionDep,
    websocket: WebSocket):
    # First, check that the token is valid in redis
    if not await redis_conn.exists(token):
        raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
    # Delete the token from redis
    await redis_conn.delete(token)
    # Accept the connection
    await websocket.accept()
    # Read the first message, which is:
    #  {
    #      'action': 'monitor_file_processing',
    #      'payload': {
    #          'file_id': "..."
    #      }
    #  }
    # Put the websocket in a try block to catch any disconnect exceptions
    try:
        message = await websocket.receive_json()
        if message['action'] != 'monitor_file_processing':
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        if 'file_id' not in message['payload']:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        # Get the file ID
        file_id = message['payload']['file_id']
        # Check that the file exists
        file = session.exec(select(File).where(File.id == file_id)).first()
        if not file:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        # Start sending back file processing statuses
        # No matter how far along the file is, send the prior statuses in order.
        # This also sends the current status
        for prior_status in ORDERED_FILE_STATUSES:
            await websocket.send_text(prior_status)
            if prior_status == file.status:
                break
        current_status = file.status
        while current_status != ORDERED_FILE_STATUSES[-1]:
            # 

        await websocket.close()
    except WebSocketDisconnect:
        # The client disconnected, so close the websocket
        await websocket.close()
