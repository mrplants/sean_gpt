""" This module contains the route for monitoring file processing status via websocket.
"""
import uuid

from fastapi import APIRouter, WebSocket, status, WebSocketException, WebSocketDisconnect, Query
from sqlmodel import select
from confluent_kafka import TopicPartition

from ...util.describe import describe
from ...config import settings
from ...util.database import RedisConnectionDep, SessionDep
from ...util.user import IsVerifiedUserDep
from ...model.file import File, ORDERED_FILE_STATUSES
from ...util.kafka_client import KafkaConsumerDep

router = APIRouter(prefix="/file/processing")

@describe(
""" Create a chat completion token.

Args:
    current_user (AuthenticatedUser):  The user making the request.

Returns:
    dict: A dictionary containing the token.
""")
@router.get("/token", dependencies=[IsVerifiedUserDep])
async def generate_chat_response( # pylint: disable=missing-function-docstring
    redis_conn: RedisConnectionDep):
    # Create the token using uuid4
    token = str(uuid.uuid4())
    # Save the token in redis with a timeout
    await redis_conn.set(token, 1, ex=settings.app_ws_token_timeout_seconds)
    # Return the token
    return {"token": token}

@describe(
""" Generates a chat completion stream via websocket.

The current file status is stored in the file record of the postgres database.  Redis is used for
inter-process communication, so there is a pubsub channel where file status notifications are
published.

Args:
    token (str):  The token generated by the /token endpoint.
    redis_conn (RedisConnectionDep):  The redis connection.
    session (SessionDep):  The database session.
    websocket (WebSocket):  The websocket connection.
    consumer (KafkaConsumerDep):  The kafka consumer.
""")
@router.websocket("/ws")
async def generate_chat_stream( # pylint: disable=missing-function-docstring
    *,
    token: str = Query(),
    redis_conn: RedisConnectionDep,
    session: SessionDep,
    websocket: WebSocket,
    consumer: KafkaConsumerDep):
    # First, check that the token is valid in redis
    if not await redis_conn.exists(token):
        raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
    # Delete the token from redis
    await redis_conn.delete(token)
    # Accept the connection
    await websocket.accept()
    # Read the first message, which is:
    #  {
    #      'action': 'monitor_file_processing',
    #      'payload': {
    #          'file_id': "..."
    #      }
    #  }
    # Put the websocket in a try block to catch any disconnect exceptions
    try:
        message = await websocket.receive_json()
        if message['action'] != 'monitor_file_processing':
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        if 'file_id' not in message['payload']:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        # Get the file ID
        file_id = message['payload']['file_id']
        # Check that the file exists
        file = session.exec(select(File).where(File.id == file_id)).first()
        if not file:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        # Start sending back file processing statuses
        # This iterates over all the messages in the kafka monitoring topic for this file
        # It continues polling and sending back messages until the final status is reached
        # or the client disconnects
        # Manually assign the partition and offset.  This is necessary because the consumer must
        # start from the beginning of the topic, which only has one partition.

        assigned_partition = TopicPartition('monitor_file_processing', 0, 0)  # topic, partition, offset
        consumer.assign([assigned_partition])

        while True:
            msg = consumer.poll(timeout=.0)
            if msg is None:
                continue
            if msg.error():
                print("Consumer error: {}".format(msg.error()))
                continue

            # Process the message...
            print(f"Received message: {msg.value().decode('utf-8')}")

        await websocket.close()
    except WebSocketDisconnect:
        # The client disconnected, so close the websocket
        await websocket.close()
