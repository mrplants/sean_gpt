""" This module contains the route for monitoring file processing status via websocket.
"""
import uuid
import json
import asyncio

from fastapi import APIRouter, WebSocket, WebSocketException, WebSocketDisconnect, Query, status
from sqlmodel import select
import aio_pika

from ...util.describe import describe
from ...config import settings
from ...util.database import RedisConnectionDep, SessionDep
from ...util.user import IsVerifiedUserDep
from ...model.file import File, ORDERED_FILE_STATUSES

router = APIRouter(prefix="/file/processing")

@describe(
""" Create a chat completion token.

Args:
    current_user (AuthenticatedUser):  The user making the request.

Returns:
    dict: A dictionary containing the token.
""")
@router.get("/token", dependencies=[IsVerifiedUserDep])
async def generate_chat_response( # pylint: disable=missing-function-docstring
    redis_conn: RedisConnectionDep):
    # Create the token using uuid4
    token = str(uuid.uuid4())
    # Save the token in redis with a timeout
    await redis_conn.set(token, 1, ex=settings.app_ws_token_timeout_seconds)
    # Return the token
    return {"token": token}

@describe(
""" Generates a chat completion stream via websocket.

The current file status is stored in the file record of the postgres database.  Redis is used for
inter-process communication, so there is a pubsub channel where file status notifications are
published.

Args:
    token (str):  The token generated by the /token endpoint.
    redis_conn (RedisConnectionDep):  The redis connection.
    session (SessionDep):  The database session.
    websocket (WebSocket):  The websocket connection.
    consumer (KafkaConsumerDep):  The kafka consumer.
""")
@router.websocket("/ws")
async def generate_chat_stream( # pylint: disable=missing-function-docstring
    *,
    token: str = Query(),
    redis_conn: RedisConnectionDep,
    session: SessionDep,
    websocket: WebSocket):
    # First, check that the token is valid in redis
    if not await redis_conn.exists(token):
        raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
    # Delete the token from redis
    await redis_conn.delete(token)
    # Accept the connection
    await websocket.accept()
    # Read the first message, which is:
    #  {
    #      'action': 'monitor_file_processing',
    #      'payload': {
    #          'file_id': "..."
    #      }
    #  }
    mq_conn = await aio_pika.connect_robust(host=settings.rabbitmq_host,
                                            login=settings.rabbitmq_secret_username,
                                            password=settings.rabbitmq_secret_password)
    async with mq_conn:
        channel = await mq_conn.channel()
        # Put the websocket in a try block to catch any disconnect exceptions
        try:
            message = await websocket.receive_json()
            if message['action'] != 'monitor_file_processing':
                raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
            if 'file_id' not in message['payload']:
                raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
            # Get the file ID
            file_id = message['payload']['file_id']
            # Check that the file exists
            file = session.exec(select(File).where(File.id == file_id)).first()
            if not file:
                raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
            # Start sending back file processing statuses, starting with the current file status
            for file_status in ORDERED_FILE_STATUSES:
                await websocket.send_json({
                    'file_id': str(file_id),
                    'status': file_status})
                if file.status == file_status:
                    break

            await channel.declare_exchange(name='monitor_file_processing', type='fanout')
            queue = await channel.declare_queue(name='', exclusive=True)
            await queue.bind(exchange='monitor_file_processing')
            async with queue.iterator() as queue_iter:
                while True:
                    try:
                        # Wait for a message for 5 seconds, then break if timeout occurs
                        message = await asyncio.wait_for(
                            queue_iter.__anext__(), # pylint: disable=unnecessary-dunder-call
                            timeout=settings.app_file_status_consumer_timeout_seconds)
                    except asyncio.TimeoutError:
                        # Break the loop if no message is received in 5 seconds
                        print(f"No message received in "
                              f"{settings.app_file_status_consumer_timeout_seconds} seconds. "
                               "Exiting.")
                        break
                    else:
                        async with message.process():
                            body = json.loads(message.body.decode('utf-8'))
                            if body['file_id'] == file_id:
                                await websocket.send_json(body)
                                if body['status'] == ORDERED_FILE_STATUSES[-1]:
                                    # Stop consuming
                                    break
            await websocket.close()
        except WebSocketDisconnect:
            # The client disconnected, so close the websocket
            await websocket.close()
