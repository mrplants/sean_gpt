""" This module contains the route for monitoring file processing status via websocket.
"""
from select import poll
import uuid
import json
import asyncio

from fastapi import APIRouter, WebSocket, status, WebSocketException, WebSocketDisconnect, Query
from sqlmodel import select
from kafka import KafkaConsumer, TopicPartition

from ...util.describe import describe
from ...config import settings
from ...util.database import RedisConnectionDep, SessionDep
from ...util.user import IsVerifiedUserDep
from ...model.file import File, ORDERED_FILE_STATUSES

router = APIRouter(prefix="/file/processing")

@describe(
""" Create a chat completion token.

Args:
    current_user (AuthenticatedUser):  The user making the request.

Returns:
    dict: A dictionary containing the token.
""")
@router.get("/token", dependencies=[IsVerifiedUserDep])
async def generate_chat_response( # pylint: disable=missing-function-docstring
    redis_conn: RedisConnectionDep):
    # Create the token using uuid4
    token = str(uuid.uuid4())
    # Save the token in redis with a timeout
    await redis_conn.set(token, 1, ex=settings.app_ws_token_timeout_seconds)
    # Return the token
    return {"token": token}

@describe(
""" Generates a chat completion stream via websocket.

The current file status is stored in the file record of the postgres database.  Redis is used for
inter-process communication, so there is a pubsub channel where file status notifications are
published.

Args:
    token (str):  The token generated by the /token endpoint.
    redis_conn (RedisConnectionDep):  The redis connection.
    session (SessionDep):  The database session.
    websocket (WebSocket):  The websocket connection.
    consumer (KafkaConsumerDep):  The kafka consumer.
""")
@router.websocket("/ws")
async def generate_chat_stream( # pylint: disable=missing-function-docstring
    *,
    token: str = Query(),
    redis_conn: RedisConnectionDep,
    session: SessionDep,
    websocket: WebSocket):
    # First, check that the token is valid in redis
    if not await redis_conn.exists(token):
        raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
    # Delete the token from redis
    await redis_conn.delete(token)
    # Accept the connection
    await websocket.accept()
    # Read the first message, which is:
    #  {
    #      'action': 'monitor_file_processing',
    #      'payload': {
    #          'file_id': "..."
    #      }
    #  }
    file_status_msg_consumer = KafkaConsumer(
        'monitor_file_processing',
        bootstrap_servers=settings.kafka_brokers,
        auto_offset_reset='earliest',
        enable_auto_commit=False,
        group_id='monitor_file_processing',
        value_deserializer=lambda x: json.loads(x.decode('utf-8')),
        key_deserializer=lambda x: x.decode('utf-8'),
        consumer_timeout_ms=settings.app_file_status_consumer_timeout_seconds * 1000
    )
    # Put the websocket in a try block to catch any disconnect exceptions
    try:
        message = await websocket.receive_json()
        if message['action'] != 'monitor_file_processing':
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        if 'file_id' not in message['payload']:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        # Get the file ID
        file_id = message['payload']['file_id']
        # Check that the file exists
        file = session.exec(select(File).where(File.id == file_id)).first()
        if not file:
            raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
        # Start sending back file processing statuses
        # This iterates over all the messages in the kafka monitoring topic for this file
        # It continues polling and sending back messages until the final status is reached
        # or the client disconnects or consumer times out

        # TODO:  This is inefficient because the consumer is synchronous.
        # DEBUG
        print('before consumer poll')
        print(f'file_id: {file_id}')

        cycles_without_records = 0
        while cycles_without_records < settings.app_file_status_consumer_timeout_seconds:
            record = file_status_msg_consumer.poll(max_records=1, update_offsets=True)
            if not record:
                print('no record')
                cycles_without_records += 1
                await asyncio.sleep(1)
                continue
            cycles_without_records = 0
            status_record = record[TopicPartition(topic='monitor_file_processing',
                                                  partition=0)][0]
            status_msg = status_record.value
            status_key = status_record.key
            if status_key == file_id:
                # Send the status message to the websocket
                await websocket.send_json(status_msg)
                if status_msg['status'] == ORDERED_FILE_STATUSES[-1]:
                    break

        file_status_msg_consumer.close()
        await websocket.close()
    except WebSocketDisconnect:
        # The client disconnected, so close the websocket
        file_status_msg_consumer.close()
        await websocket.close()
